head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2008.12.11.15.34.43;	author raap;	state Exp;
branches;
next	;


desc
@THE kernel
@


1.1
log
@Initial revision
@
text
@/*
    kernel.c
    Copyright (C) 2008  

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "lpc2220.h"
#include "global.h"
#include "irq.h"
#include "kernel.h"

#define ttt_length	20

/* Frequency, with which timer0 shall count 
   Here: 1 MHz
*/
#define T0FREQ	1000000

/* Interval in microseconds, after which timer0 shall generate an interrupt
  Here: 10 ms
*/
#define T0PERIOD 10000


/* The following variables may be changed by interrupt service routines */
volatile static unsigned int sys_time;		// monotonically increasing system time (time ticks since boot)
volatile static unsigned int time_slot;		// current index into timetask_tablet
volatile unsigned int pending_tasks;		// signals 

static unsigned int timetask_table[ttt_length];

/* Setting of signals must be an atomic operation, because it is a read-modify-write operation 

	We have two different set of functions: one which we can call from thumb code,
	the other callable from normal code
*/
void __attribute__ ((section(".text.fastcode"))) signal_set_(int taskid){
	disableVIC_();
	pending_tasks |= (1<<taskid);
	enableVIC_();	
};

void __attribute__ ((section(".text.fastcode"))) signal_clr_(int taskid){
	disableVIC_();
	pending_tasks &= ~(1<<taskid);
	enableVIC_();	
};


void signal_set(int taskid){
	disableIRQ();
	pending_tasks |= (1<<taskid);
	enableIRQ();	
};

void signal_clr(int taskid){
	disableIRQ();
	pending_tasks &= ~(1<<taskid);
	enableIRQ();	
};

/* Returns the current system time (in 1/100th of a second) */
unsigned int system_time(){
	return (sys_time);
};

/* Adds a TimeTask to the time task table.
	TaskId is a number from 0 to 31
	div tells us how often the task shall be executed.
	div=1 means every time tick
	div=2 means every second time tick etc.
*/
void AddTimeTask(unsigned int TaskId, unsigned int div){
	int i;
	if ((div == 0) || (div >= ttt_length)) return;
	
	for (i=0; i<ttt_length; i+=div)
		timetask_table[i] |= (1<<TaskId);
};

/* Remove a time task from the time task table */
void RemoveTimeTask(unsigned int TaskId){
	int i;
	
	for (i=0; i<ttt_length; i++)
		timetask_table[i] &= ~(1<<TaskId);
};

/* This routine is called when an interrupt for timer0 channel0 match occurs 
	Assigned to VIC vector slot 15
	
	We want to have some time based tasks, i.e. tasks that run at a fixed interval.
	This routine keeps a tick counter, which is incremented at every timer0 channel0 match
	and is reset to 0 when ttt_length is reached.
	This way we generate ttt_length time slots.
	For every time slot the timetask_table tells us, which tasks want to run at this point.
	We simply OR this mask with the still pending tasks to get the new pending_tasks mask.
*/
void __attribute__ ((section(".text.fastcode"))) timerIRQ(void)
{
	/* Clear interrupt for Channel 0 Match */
	T0IR = 1;
	
	sys_time++;			/* increment the system time */
	time_slot++;
	if (time_slot >= ttt_length)
		time_slot = 0;

	pending_tasks |= timetask_table[time_slot];
}


void __attribute__ ((section(".text.fastcode"))) defaultIRQ(void){

	signal_set_(31);
};


/* Start timer0. To be called once at startup.
	The timer0 interrupt routine timerIRQ() is bound to VIC slot 15 (lowest priority)
	and enabled
*/
static void startTimerIRQ(){
	
	T0TCR = 0x02;		// Stop the timer, reset the counter and prescaler to 0
	
	T0CTCR = 0x00;		// Timer mode, count every rising PCLK edge
	
	T0TC = 0;		// Starting counter value
	T0PR = (PCLK/T0FREQ)-1; // We calculate PR so that we get a counting frequency of 1 microsecond. (15 MHz / 15 = 1 MHz)
	
	T0MR0 = T0PERIOD;	// Match register 0
	T0MCR = 0x03;		// Interrupt on match register 0 and reset counter

	VICIntSelect &= ~INT_TIMER0;
	VICVectAddr15 = (unsigned long)&(timerIRQ);
	VICVectCntl15 = VIC_SLOT_EN | INT_SRC_TIMER0;
	VICIntEnable = INT_TIMER0;
	

	T0TCR = 0x01;	// Start the timer
}
	
	
/* To be called once at startup */
void kernel_init(){
	pending_tasks = 0;
	sys_time = 0;	
	time_slot = 0;
	
	VICDefVectAddr = (unsigned long) &(defaultIRQ);
	
	startTimerIRQ();
};

/* To be called before each normal task is executed.
	Checks if there are any urgent prioritized tasks
	and executes them if necessary
*/
void check_events (){
	
#ifdef	EVENT1
	if (EVENT1)
		EVENT1_TASK;
#endif

};

@
